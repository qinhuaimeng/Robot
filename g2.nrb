<?xml version="1.0" encoding="gb2312"?>
<File robottype="NST-STM-YD" filetype="4" ver="1.0.0" author=""><PortConfig id=" value="></PortConfig><Data>#include "main.h"
#define f0 EXP_analog(0,KZ[1][7])
#define f1 EXP_analog(0,KZ[1][6])
#define f2 EXP_analog(0,KZ[1][5])
#define f3 EXP_analog(0,KZ[1][4])
#define f4 EXP_analog(0,KZ[1][3])
#define f5 EXP_analog(0,KZ[1][2])
#define f6 EXP_analog(0,KZ[1][1])
#define f7 EXP_analog(0,KZ[1][0])

#define b0 EXP_analog(1,KZ[1][0])
#define b1 EXP_analog(1,KZ[1][1])
#define b2 EXP_analog(1,KZ[1][2])
#define b3 EXP_analog(1,KZ[1][3])
#define b4 EXP_analog(1,KZ[1][4])
#define b5 EXP_analog(1,KZ[1][5])
#define b6 EXP_analog(1,KZ[1][6])
#define b7 EXP_analog(1,KZ[1][7])

#define g_I_AIL_M_Left  analog(3)
#define g_I_AIL_M_Right analog(6)

int i;
int j;
int mid[18];

void dingwei(int s);
void xunxian(int s,int num);
void zuozhuan(int s,int q);
void youzhuan(int s);
void option(int s);
void option1(int s);
void option2(int s);
void option3(int s);

void move(int b,int a)
{
	motor(0,a);
	motor(1,b);
}


               

void ceguang()                                          ///////////////////////////测光
{
	int max[18];
	int min[18];
	
	max[0]=f0;
	max[1]=f1;
	max[2]=f2;
	max[3]=f3;
	max[4]=f4;
	max[5]=f5;
	max[6]=f6;
	max[7]=f7;
	
	max[8]=b0;
	max[9]=b1;
	max[10]=b2;
	max[11]=b3;
	max[12]=b4;
	max[13]=b5;
	max[14]=b6;
	max[15]=b7;
	
	max[16]=g_I_AIL_M_Left;
	max[17]=g_I_AIL_M_Right;
	
	
	min[0]=f0;
	min[1]=f1;
	min[2]=f2;
	min[3]=f3;
	min[4]=f4;
	min[5]=f5;
	min[6]=f6;
	min[7]=f7;
	
	min[8]=b0;
	min[9]=b1;
	min[10]=b2;
	min[11]=b3;
	min[12]=b4;
	min[13]=b5;
	min[14]=b6;
	min[15]=b7;
	
	min[16]=g_I_AIL_M_Left;
	min[17]=g_I_AIL_M_Right;
	
	for(i=0;i&lt;=60;i++)
	for(j=0;j&lt;=60;j++)
	{
		move(20,20);
		if(max[0]&lt;f0)
		max[0]=f0;
		if(max[1]&lt;f1)
		max[1]=f1;
		if(max[2]&lt;f2)
		max[2]=f2;
		if(max[3]&lt;f3)
		max[3]=f3;
		if(max[4]&lt;f4)
		max[4]=f4;
		if(max[5]&lt;f5)
		max[5]=f5;
		if(max[6]&lt;f6)
		max[6]=f6;
		if(max[7]&lt;f7)
		max[7]=f7;
		
		if(max[8]&lt;b0)
		max[8]=b0;
		if(max[9]&lt;b1)
		max[9]=b1;
		if(max[10]&lt;b2)
		max[10]=b2;
		if(max[11]&lt;b3)
		max[11]=b3;
		if(max[12]&lt;b4)
		max[12]=b4;
		if(max[13]&lt;b5)
		max[13]=b5;
		if(max[14]&lt;b6)
		max[14]=b6;
		if(max[15]&lt;b7)
		max[15]=b7;
		if(max[16]&lt;g_I_AIL_M_Left)
		max[16]=g_I_AIL_M_Left;
		if(max[17]&lt;g_I_AIL_M_Right)
		max[17]=g_I_AIL_M_Right;
		
		if(min[0]&gt;f0)
		min[0]=f0;
		if(min[1]&gt;f1)
		min[1]=f1;
		if(min[2]&gt;f2)
		min[2]=f2;
		if(min[3]&gt;f3)
		min[3]=f3;
		if(min[4]&gt;f4)
		min[4]=f4;
		if(min[5]&gt;f5)
		min[5]=f5;
		if(min[6]&gt;f6)
		min[6]=f6;
		if(min[7]&gt;f7)
		min[7]=f7;
		
		if(min[8]&gt;b0)
		min[8]=b0;
		if(min[9]&gt;b1)
		min[9]=b1;
		if(min[10]&gt;b2)
		min[10]=b2;
		if(min[11]&gt;b3)
		min[11]=b3;
		if(min[12]&gt;b4)
		min[12]=b4;
		if(min[13]&gt;b5)
		min[13]=b5;
		if(min[14]&gt;b6)
		min[14]=b6;
		if(min[15]&gt;b7)
		min[15]=b7;
		
		if(min[16]&gt;g_I_AIL_M_Left)
		min[16]=g_I_AIL_M_Left;
		if(min[17]&gt;g_I_AIL_M_Right)
		min[17]=g_I_AIL_M_Right;
	}
	for(i=0;i&lt;18;i++)
	{
		mid[i]=(max[i]+min[i])/2;
		printf("%d ",mid[i]);
		if(i%8==0) printf("\n");
	}
}
void zuozhuan(int s,int q)
{
	while(f0&lt;mid[0])
	move(-s,q);
	while(f3&lt;mid[3])
	move(-s,q);

}

void youzhuan(int s,int q)
{
	while(f7&lt;mid[7])
	move(s,-q);
	while(f4&lt;mid[4])
	move(-s,q);
}


void dingwei(int s){
	while(g_I_AIL_M_Left&lt;mid[16]&amp;&amp;g_I_AIL_M_Right&gt;mid[17]){
		move(s,s);
	}
}




void xunxian(int s,int num)       /////////////////////////巡线
{
	switch(num)
	{
		case 1:
		{
			option(s);
			break;
		}
		case 2:
		{
			option1(s);
			break;
		}
		case 3:
		{
			option2(s);
			break;
		}
	 
	}
}



void option(int s)                           /////////////////////////////option
{
	switch(f3&gt;f4?0:1)
	{
		case 0:{
			switch(f2&gt;f3?0:1)
			{
				case 0:move(s,(f2-f3)/8*0.5+s); break;
				case 1:move(s,(f3-f4)/10*0.5+s); break;
				
			}
			}break;
		case 1:{
			switch(f4&gt;f5?0:1)
			{
				case 0:move((f4-f3)/10*0.5+s,s);break;
				case 1:move((f5-f3)/8*0.5+s,s);break;
			}
			}break;
	}
}


void option1(int s)
{
	switch(f3&gt;f4?0:1)
	{
		case 0:{
			switch(f2&gt;f3?0:1)
			{
				case 0:move(s,(f2-f3)/8*3+s); break;
				case 1:move(s,(f3-f4)/10*3+s); break;
				}}break;
		case 1:{
			switch(f4&gt;f5?0:1)
			{
				case 0:move((f4-f3)/10*3+s,s);break;
				case 1:move((f5-f3)/8*3+s,s);break;
				}}break;
	}
}


void option2(int s)/////////////////////////巡线
{
	while(f0&lt;mid[0]&amp;&amp;f7&lt;mid[7])
	{
		if(f3&gt;mid[3]&amp;&amp;f4&gt;mid[4])
		move(s,s);
		else if(f3&gt;mid[3]&amp;&amp;f4&lt;mid[4])
		move(s,s+10);
		else if(f3&lt;mid[3]&amp;&amp;f4&gt;mid[4])
		move(s+10,s);
		else if(f2&gt;mid[2]&amp;&amp;f5&lt;mid[5])
		move(s,s+15);
		else if(f2&lt;mid[2]&amp;&amp;f5&gt;mid[5])
		move(s+15,s);
		else if(f1&gt;mid[1]&amp;&amp;f6&lt;mid[6])
		move(s,s+25);
		else if(f1&lt;mid[1]&amp;&amp;f6&gt;mid[6])
		move(s+25,s);
		else move(s,s);
	}
}



int main(){
	RobotInit();           /*该函数用于机器人初始化，请勿删除!*/
	ceguang();  ////先只测试测光跑多远，调好距离后加上其他程序
	xunxian(15,3); 
//	dingwei(15);/////根据测光距离写后面大程序，可能不是定位了
//	zuozhuan(15,25);
//	xunxian(15,3);
//	dingwei(15);
//	youzhuan(15);
	
//	xunxian(15,2);/////////两个数字写反了，调回去看一下s,num代表的。
	stop();
}
</Data></File>
